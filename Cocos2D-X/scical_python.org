
* Numpy：操作与处理数据

** 什么是 Numpy 和 Numpy 数组

*** Numpy数组

*** Numpy参考文档

    + 在线版： [[http://docs.scipy.org]]
    + 交互式：
      #+BEGIN_SRC python
        np.array?
      #+END_SRC
    + 查询某种结构或功能
      #+BEGIN_SRC python
        np.lookfor('create array')
      #+END_SRC

      #+BEGIN_SRC python
        np.con?
      #+END_SRC

*** 导入Numpy的建议
    #+BEGIN_SRC python
      import numpy as np
    #+END_SRC

** 创建 Numpy 数组

*** 手动创建数组

    + 一维数组：
      #+BEGIN_SRC python
        import numpy as np
        a = np.array([0,1,2,3])
        a.ndim
        a.shape
        len(a)
      #+END_SRC

    + 二维及多维数组
      #+BEGIN_SRC python
        import numpy as np
        b = np.array([[0,1,2], [3,4,5]])
        c = np.array([[[1], [2]], [[3], [4]]])
      #+END_SRC



*** 用函数创建数组

    + 等间距分布的数组
      #+BEGIN_SRC python
        a = np.arange(10) # 0 .. n-1
      #+END_SRC

    + 指定数量的数组
      #+BEGIN_SRC python
        c = np.linspace(0, 1, 6) # start, end, num-points
        c = np.linspace(0, 1, 5, endpoint = False)
      #+END_SRC

    + 一些常用的数组
      #+BEGIN_SRC python
        a = np.ones((3,3))
        b = np.zeros((2,2))
        c = np.eye(3)
        d = np.diag(np.array([1,2,3,4]))
      #+END_SRC

    + =np.random= 随机数组(梅森旋转算法生成)
      #+BEGIN_SRC python
        a = np.random.rand(4) # uniform in [0,1]
        b = np.random.randn(4) # Gaussian
        np.random.seed(1234) # settiing the random seed
      #+END_SRC

** 基本数据类型

   1. Numpy 会自动检测输入的数据类型
   2. 可以显式指定数据类型
      #+BEGIN_SRC python
        c = np.array([1,2,3], dtype=float)
        c.dtype
      #+END_SRC
   3. 默认的数据类型是浮点型
      #+BEGIN_SRC python
        a = np.ones((3,3))
        a.dtype
      #+END_SRC

** 基本的数据可视化

   1. 打开 =IPython=, 或者方便起见，使用 =jupyter notebook=
   2. 打开交互绘图功能
      #+BEGIN_SRC python
        %matplotlib inline
      #+END_SRC
      =inline= 可以让我们在 =notebook= 里就能看到图，不会打开新的窗口
   3. 导入 =Matplotlib= 包
      #+BEGIN_SRC python
        import matplotlib.pyplot as plt
      #+END_SRC
   4. 然后可以使用，注意，如果没有使用 =%matplotlib inline=, 要显示图片，需要显式地调用 =show= 命令
      #+BEGIN_SRC python
        plt.plot(x,y)
        plt.show()
      #+END_SRC
      如果执行了 =%matplotlib inline=, 可以更简单
      #+BEGIN_SRC python
        plot(x,y)
      #+END_SRC

   5. 图像
      + 一维图像

        #+BEGIN_SRC python
          x = np.linspace(0, 3, 20)
          y = np.linspace(0, 9, 20)
          plt.plot(x, y) #inline plot
          plt.plot(x, y, 'o') #dot plot
        #+END_SRC

      + 二维图像

        #+BEGIN_SRC python
          image = np.random.rand(30, 30)
          plt.imshow(image, cmap=plt.cm.hot)
          plt.colorbar()
        #+END_SRC

** 索引与切片
*** 索引
   1. =array= 中元素可以通过索引取得
      #+BEGIN_SRC python
        >>> a = np.arange(10)
        >>> a[0]
        0
        >>> a[2]
        2
      #+END_SRC
   2. =array= 元素倒序
      #+BEGIN_SRC python
        >>> a[::-1]
      #+END_SRC
   3. 对于多维的 =array=, 其中元素的指标是用 =tuple= 保存的整数
      #+BEGIN_SRC python
        >>> a = np.diag(np.arange(3))
        >>> a
        array([[0, 0, 0],
               [0, 1, 0],
               [0, 0, 2]])
        >>> a[1,1], a[2,1]
        (1, 0)
      #+END_SRC

*** 切片
    1. =array= 可以和其他 =Python= 内置的序列一样进行切片
       #+BEGIN_SRC python
         >>> import numpy as np
         >>> a = np.arange(10)
         >>> a
         array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
         >>> a[2:9:3]
         array([2, 5, 8])
       #+END_SRC
    2. 注意，最后一个索引不会被取出
       #+BEGIN_SRC python
         >>> a[:4]
         array([0, 1, 2, 3])
       #+END_SRC
    3. 切片语法中三个 components 并不是必须的，默认值是， =start= 是 0， =end= 是最后一个元素， =step= 是 1
       #+BEGIN_SRC python
         >>> a[1:3]
         array([1, 2])
         >>> a[::2]
         array([0, 2, 4, 6, 8])
         >>> a[3:]
         array([3, 4, 5, 6, 7, 8, 9])
       #+END_SRC

*** 总结
    关于 =Indexing= 和 =Slicing=, 下图是它们的一个总结
    [[file:Pictures/Scipy/numpy_indexing.png]]

** 复制与查看
   一个 =slicing= 的操作会给原始的 =array= 创建一个 =view=, 这样原始的 =array= 不会复制到内存中。
   利用 =np.may_share_memory()= 函数可以查看两个 =array= 是否共享同样的内存地址。

   #+BEGIN_SRC python
     >>> a = np.arange(10)
     >>> a
     array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
     >>> b = a[::2]
     >>> b
     array([0, 2, 4, 6, 8])
     >>> np.may_share_memory(a,b)
     True
     >>> b[0] =12
     >>> b
     array([12,  2,  4,  6,  8])
     >>> a
     array([12,  1,  2,  3,  4,  5,  6,  7,  8,  9])
     >>>
     >>> a = np.arange(10)
     >>> c = a[::2].copy()
     >>> c[0] = 12
     >>> a
     array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
     >>> c
     array([12,  2,  4,  6,  8])
     >>> np.may_share_memory(a,c)
     False
   #+END_SRC

***  埃式筛法的 =Python= 实现
